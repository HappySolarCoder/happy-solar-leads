<!DOCTYPE html>
<html>
<head>
    <title>React Code Path Test</title>
    <style>
        body { font-family: Arial; padding: 20px; background: #1a1a1a; color: #eee; }
        button { padding: 12px 24px; font-size: 16px; background: #0066cc; color: white; border: none; border-radius: 5px; cursor: pointer; margin: 5px; }
        pre { background: #222; color: #0f0; padding: 15px; border-radius: 5px; white-space: pre-wrap; }
        .pass { color: #44ff44; }
        .fail { color: #ff4444; }
    </style>
</head>
<body>
    <h1>React Code Path Test</h1>
    <p>Click to test the EXACT code path the React app uses:</p>
    <button onclick="testReactPath()">Test React Upload Path</button>
    <button onclick="checkLeads()">Check Leads</button>
    <button onclick="clearAll()">Clear All</button>
    <pre id="out"></pre>

    <script>
        const API_KEY = 'AIzaSyCVbiweX65EncP7RyF6HZk0Y1_1ZosX_D8';
        const GEOCODE_BASE = 'https://maps.googleapis.com/maps/api/geocode/json';

        function out(msg, type) {
            const el = document.getElementById('out');
            const color = type === 'pass' ? 'pass' : type === 'fail' ? 'fail' : '';
            el.innerHTML += `<span class="${color}">${msg}</span>\n`;
        }

        function clearAll() {
            localStorage.removeItem('happysolar_leads');
            localStorage.removeItem('happysolar_currentuser');
            localStorage.removeItem('happysolar_users');
            localStorage.removeItem('happy_solar_geocode_cache');
            out('Cleared all localStorage', 'info');
        }

        function checkLeads() {
            const leads = JSON.parse(localStorage.getItem('happysolar_leads') || '[]');
            out(`Found ${leads.length} leads:`, 'info');
            leads.forEach((l, i) => {
                out(`  ${i+1}. ${l.name} - ${l.address}`, '');
            });
        }

        // === EXACT COPY OF React App Code ===

        // From storage.ts
        function getLeads() {
            if (typeof window === 'undefined') return [];
            const data = localStorage.getItem('happysolar_leads');
            if (!data) return [];
            try {
                return JSON.parse(data);
            } catch { return []; }
        }

        function saveLeads(leads) {
            if (typeof window === 'undefined') return;
            localStorage.setItem('happysolar_leads', JSON.stringify(leads));
        }

        function addLead(lead) {
            const leads = getLeads();
            leads.push(lead);
            saveLeads(leads);
        }

        function generateId() {
            return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }

        // From geocode.ts
        const GEOCODE_CACHE_KEY = 'happy_solar_geocode_cache';
        let addressCache = null;

        function loadCache() {
            if (addressCache) return addressCache;
            try {
                const cached = localStorage.getItem(GEOCODE_CACHE_KEY);
                if (cached) {
                    addressCache = new Map(Object.entries(JSON.parse(cached)));
                } else {
                    addressCache = new Map();
                }
            } catch (e) {
                out('Cache load error: ' + e.message, 'fail');
                addressCache = new Map();
            }
            return addressCache;
        }

        function saveCache() {
            if (!addressCache) return;
            try {
                localStorage.setItem(GEOCODE_CACHE_KEY, JSON.stringify(Object.fromEntries(addressCache)));
            } catch (e) {
                out('Cache save error: ' + e.message, 'fail');
            }
        }

        function getCacheKey(row) {
            return `${row.address?.toLowerCase().trim()}, ${row.city?.toLowerCase().trim()}, ${row.state?.toLowerCase().trim()} ${row.zip?.trim()}`;
        }

        async function geocodeAddress(row) {
            const cached = (() => {
                const c = loadCache();
                const key = getCacheKey(row);
                return c.get(key) || null;
            })();
            if (cached) {
                out(`Cache hit: ${row.address}`, 'info');
                return cached;
            }

            const query = `${row.address}, ${row.city}, ${row.state} ${row.zip}`;
            const url = `${GEOCODE_BASE}/json?address=${encodeURIComponent(query)}&key=${API_KEY}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.status === 'OK' && data.results && data.results.length > 0) {
                    const location = data.results[0].geometry.location;
                    const coords = { lat: location.lat, lng: location.lng };
                    const c = loadCache();
                    c.set(getCacheKey(row), coords);
                    saveCache();
                    return coords;
                }
                return null;
            } catch (error) {
                out('Geocode error: ' + error.message, 'fail');
                return null;
            }
        }

        async function geocodeBatch(rows, onProgress) {
            const results = [];
            const cache = loadCache();
            const uncachedRows = [];
            const uncachedIndices = [];

            for (let i = 0; i < rows.length; i++) {
                const cached = (() => {
                    const c = loadCache();
                    const key = getCacheKey(rows[i]);
                    return c.get(key) || null;
                })();
                if (cached) {
                    results.push({ row: rows[i], lat: cached.lat, lng: cached.lng });
                } else {
                    uncachedRows.push(rows[i]);
                    uncachedIndices.push(i);
                }
            }

            out(`Batch: ${rows.length} total, ${uncachedRows.length} need geocoding`, 'info');

            const BATCH_SIZE = 10;
            for (let batchStart = 0; batchStart < uncachedRows.length; batchStart += BATCH_SIZE) {
                const batchEnd = Math.min(batchStart + BATCH_SIZE, uncachedRows.length);
                const batch = uncachedRows.slice(batchStart, batchEnd);
                const batchIndices = uncachedIndices.slice(batchStart, batchEnd);

                const promises = batch.map(async (row, idx) => {
                    const coords = await geocodeAddress(row);
                    return { coords, originalIndex: batchIndices[idx] };
                });

                const batchResults = await Promise.all(promises);

                for (const { coords, originalIndex } of batchResults) {
                    results[originalIndex] = {
                        row: rows[originalIndex],
                        lat: coords?.lat,
                        lng: coords?.lng,
                    };
                }

                onProgress?.(batchEnd, rows.length);
            }

            return results;
        }

        // Main test function
        async function testReactPath() {
            document.getElementById('out').innerHTML = '';
            out('=== Testing React Upload Path ===\n', 'info');

            const testRows = [
                { name: 'React Test 1', address: '1000 S Winton Rd', city: 'Rochester', state: 'NY', zip: '14618', phone: '555-0001', email: 't1@test.com' },
                { name: 'React Test 2', address: '500 E Main St', city: 'Rochester', state: 'NY', zip: '14604', phone: '555-0002', email: 't2@test.com' },
            ];

            try {
                out('1. Starting geocodeBatch...', 'info');
                const results = await geocodeBatch(testRows, (current, total) => {
                    out(`   Progress: ${current}/${total}`, 'info');
                });
                out(`2. Geocode complete. Results: ${results.length}`, 'info');

                const successful = results.filter(r => r.lat && r.lng);
                const failed = results.filter(r => !r.lat || !r.lng);

                out(`3. Successful: ${successful.length}`, successful.length > 0 ? 'pass' : 'fail');
                out(`   Failed: ${failed.length}`, failed.length > 0 ? 'fail' : 'info');

                if (failed.length > 0) {
                    failed.forEach(f => out(`   - ${f.row.address}`, 'fail'));
                }

                out('\n4. Creating leads...', 'info');
                const newLeads = successful.map(result => ({
                    id: generateId(),
                    name: result.row.name || 'Unknown',
                    address: result.row.address,
                    city: result.row.city,
                    state: result.row.state,
                    zip: result.row.zip,
                    phone: result.row.phone,
                    email: result.row.email,
                    lat: result.lat,
                    lng: result.lng,
                    status: 'unclaimed',
                    createdAt: new Date().toISOString(),
                }));

                out(`   Created ${newLeads.length} leads`, 'info');

                out('\n5. Saving to localStorage...', 'info');
                newLeads.forEach(lead => {
                    out(`   Adding: ${lead.name} - ${lead.address}`, 'info');
                    addLead(lead);
                });

                out('\n6. Verifying...', 'info');
                const finalLeads = getLeads();
                out(`   Total leads: ${finalLeads.length}`, finalLeads.length > 0 ? 'pass' : 'fail');

                if (finalLeads.length > 0) {
                    out('\n✅ SUCCESS! Leads are being saved correctly.', 'pass');
                    out('If app shows 0 leads, the issue is in React state/re-render.', 'info');
                } else {
                    out('\n❌ FAIL: No leads found after save', 'fail');
                }

            } catch (e) {
                out('❌ Error: ' + e.message, 'fail');
                out(e.stack, 'fail');
            }
        }
    </script>
</body>
</html>
